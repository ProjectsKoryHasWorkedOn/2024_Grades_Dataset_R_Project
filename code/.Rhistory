OULADDataCleaner$setDataset(studentInfoTable)
OULADDataCleaner$replaceValuesEqualToXWithAValue(8, '55<=', ">55")
studentInfoTable <- OULADDataCleaner$returnDataset()
# Handle poorly entered qualification levels
OULADDataCleaner$setDataset(studentInfoTable)
OULADDataCleaner$replaceValuesEqualToXWithAValue(6, 'No Formal quals', "No recognized qualifications")
studentInfoTable <- OULADDataCleaner$returnDataset()
# Handle wrongly entered IMD band value ('10-20' value is missing a % sign, it should be '10-20%')
OULADDataCleaner$setDataset(studentInfoTable)
OULADDataCleaner$replaceValuesEqualToXWithAValue(7, '10-20', "10-20%")
studentInfoTable <- OULADDataCleaner$returnDataset()
# Handle missing IMD band values
OULADDataChecker$setDataset(studentInfoTable)
OULADDataChecker$calculateWhatUniqueValuesWeHaveInAColumn(7)
whatUniqueValuesWeHaveInIMDBand <-
OULADDataChecker$returnWhatUniqueValuesWeHaveInAColumn()
# Can see that there are 'NA' values so that's what we'll be dealing with
# [1] "90-100%" "20-30%"  "30-40%"  "50-60%"  "80-90%"  "70-80%"  NA        "60-70%"  "40-50%"  "10-20%"  "0-10%"
# Return what the most common IMD band value is for ONE particular region
returnMostCommonIMDBandValue <- function(regionArg) {
ZeroToTen <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '0-10%'
),
na.rm = TRUE
)
TenToTwenty <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '10-20%'
),
na.rm = TRUE
)
TwentyToThirty <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '20-30%'
),
na.rm = TRUE
)
ThirtyToFourty <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '30-40%'
),
na.rm = TRUE
)
FourtyToFifty <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '40-50%'
),
na.rm = TRUE
)
FiftyToSixty <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '50-60%'
),
na.rm = TRUE
)
SixtyToSeventy <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '60-70%'
),
na.rm = TRUE
)
SeventyToEighty <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '70-80%'
),
na.rm = TRUE
)
EightyToNinety <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '90-100%'
),
na.rm = TRUE
)
NinetyToHundred <-
sum(
str_count(
regionArg$index_of_multiple_deprivation_for_a_uk_region,
pattern = '0-10%'
),
na.rm = TRUE
)
AllTheValues <-
c(
ZeroToTen,
TenToTwenty,
TwentyToThirty,
ThirtyToFourty,
FourtyToFifty,
FiftyToSixty,
SixtyToSeventy,
SeventyToEighty,
EightyToNinety,
NinetyToHundred
)
theBiggestOne <- which.max(AllTheValues)
returnValue <- switch(
theBiggestOne,
'0-10%',
'10-20%',
'20-30%',
'30-40%',
'40-50%',
'50-60%',
'60-70%',
'70-80%',
'80-90%',
'90-100%'
)
return(returnValue)
}
# Return a list of the most common IMD values for A LIST OF regions
returnMostCommonIMDValuesForAListOfRegions <-
function(tableArg, regionsArg, numberOfRegionsArg) {
whatIsMostCommonOne = 0
for (x in 1:numberOfRegionsArg) {
currentRegion <-
filter(tableArg,
region_student_lived_in_while_taking_the_module == regionsArg[x])
whatIsMostCommonOne[x] <-
returnMostCommonIMDBandValue(currentRegion)
}
return(whatIsMostCommonOne)
}
# Get just the studentInfoTable with the columns of interest to us
OULADDataSubsetter$setDataset(studentInfoTable)
OULADDataSubsetter$getSubsetOfDataset(c(3, 5, 7))
subsetOfStudentInfoTable <-
OULADDataSubsetter$returnSubsetOfDataset()
# Get just the subsetOfStudentInfoTable with the regions that have missing values for the IMD value
OULADDataSubsetter$setDataset(subsetOfStudentInfoTable)
OULADDataSubsetter$getSubsetOfDatasetWithMissingColumns(3)
whichRegionsHaveAMissingValue <-
OULADDataSubsetter$returnSubsetOfDataset()
# Get the names of the regions that have missing values for the IMD value
OULADDataChecker$setDataset(whichRegionsHaveAMissingValue)
OULADDataChecker$calculateWhatUniqueValuesWeHaveInAColumn(2)
whatAreTheNamesOfTheseRegions <-
OULADDataChecker$returnWhatUniqueValuesWeHaveInAColumn()
# Get the number of regions that have missing values for the IMD value
whatIsTheNumberOfTheseRegions = length(whatAreTheNamesOfTheseRegions[[1]])
# Get the common IMD value for regions that have missing values for the IMD value
mostCommonOnes <-
returnMostCommonIMDValuesForAListOfRegions(
subsetOfStudentInfoTable,
whatAreTheNamesOfTheseRegions[[1]],
whatIsTheNumberOfTheseRegions
)
names(mostCommonOnes) <- whatAreTheNamesOfTheseRegions[[1]]
# Replace missing IMD values with the name of the region
OULADDataCleaner$setDataset(subsetOfStudentInfoTable)
OULADDataCleaner$replaceValueIfMissingWithAValueIfNotMissingKeepValue(3, 2)
subsetOfStudentInfoTable$index_of_multiple_deprivation_for_a_uk_region <-
OULADDataCleaner$returnReplacementColumn()
# Replace the names of the region with the most common IMD value in that region
for (i in 1:nrow(subsetOfStudentInfoTable)) {
currentValue <-
subsetOfStudentInfoTable$index_of_multiple_deprivation_for_a_uk_region[i]
if (currentValue %in% names(mostCommonOnes)) {
indexValue <- which(currentValue == names(mostCommonOnes))
subsetOfStudentInfoTable$index_of_multiple_deprivation_for_a_uk_region[i] <-
mostCommonOnes[indexValue]
}
}
# Replacing NA values in our studentInfoTable with values in our subsetOfStudentInfoTable
# that now contain some IMD values we've come up with
studentInfoTable$index_of_multiple_deprivation_for_a_uk_region <-
subsetOfStudentInfoTable$index_of_multiple_deprivation_for_a_uk_region
# --
# -- Cleanup operations for the studentRegistrationTable in the OULAD database
# Clarify that if the date the student unregistered field is empty then this means that
# either the student is still in the course or has completed the course
OULADDataCleaner$setDataset(studentRegistrationTable)
OULADDataCleaner$replaceMissingValueWithAValueReworked(5, "In/Completed course")
studentRegistrationTable$student_days_it_took_them_to_unregister_relative_to_the_module_starting_day <-
OULADDataCleaner$returnReplacementColumn()
# Make it so if the day the student registered into the course is missing, it is on the day the course started
OULADDataCleaner$setDataset(studentRegistrationTable)
OULADDataCleaner$replaceMissingValueWithAValueReworked(4, 0)
studentRegistrationTable$student_days_it_took_them_to_register_relative_to_the_module_starting_day <-
OULADDataCleaner$returnReplacementColumn()
# --
# -- Data checking
# Checking for duplicate IDs for PKs
# Worked out PKs through looking at the tables
OULADDataChecker$setDataset(assessmentsTable)
OULADDataChecker$checkForDuplicateValues(3) # assessment_id
wereDuplicateAssessmentIDsFound <-
OULADDataChecker$returnIfDuplicateValuesWereFound()
OULADDataChecker$setDataset(VLETable)
OULADDataChecker$checkForDuplicateValues(1) # vle_material_id
wereDuplicateVLEMaterialIDsFound <-
OULADDataChecker$returnIfDuplicateValuesWereFound()
OULADDataChecker$calculateNumberOfMissingValues()
wereMissingValuesFound <-
OULADDataChecker$returnNumberOfMissingValues()
# courses table and student info table have duplicates, no PK in them
# --
# Drop columns with lots of missing values
OULADDataCleaner$setDataset(VLETable)
OULADDataCleaner$removeJunkColumns(c(5, 6))
VLETable <- OULADDataCleaner$returnDataset()
# --
# -- Merge a number of the tables together
# Wasn't able to merge VLETable and StudentVLETables - Wasn't finishing this operation in a reasonable time on one's laptop
# Merge student assessment table + assessments table
OULADDataSupersetter$setDataset(studentAssessmentTable)
OULADDataSupersetter$setSecondDataset(assessmentsTable)
mergedAssessmentTableAndStudentAssessmentTable <-
OULADDataSupersetter$mergeTwoTables("assessment_id")
# Merge student assessment table + assessments + student registration table
OULADDataSupersetter$setDataset(mergedAssessmentTableAndStudentAssessmentTable)
OULADDataSupersetter$setSecondDataset(studentRegistrationTable)
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTable <-
OULADDataSupersetter$mergeTwoTablesSharedIDs(
c("student_id", "module_id", "presentation_id"),
c("student_id", "module_id", "presentation_id")
)
# Merge student assessment table + assessments + student registration + student info table
OULADDataSupersetter$setDataset(mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTable)
OULADDataSupersetter$setSecondDataset(studentInfoTable)
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoTable <-
OULADDataSupersetter$mergeTwoTablesSharedIDs(
c("student_id", "module_id", "presentation_id"),
c("student_id", "module_id", "presentation_id")
)
# Merge student assessment table + assessments + student registration + student info + courses table
OULADDataSupersetter$setDataset(mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoTable)
OULADDataSupersetter$setSecondDataset(coursesTable)
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable <-
OULADDataSupersetter$mergeTwoTablesSharedIDs(
c("module_id", "presentation_id"),
c("module_id", "presentation_id")
)
# view(mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable)
# --
# -- Cleanup operations for the mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable
# Handle missing exam due dates. The end of the last week of the course is the last day of the course.
# The start of the last week of the course would be days in course - 7
OULADDataCleaner$setDataset(mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable)
OULADDataCleaner$replaceValueIfMissingWithAValueIfNotMissingKeepValue(9, 22)
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable$assessment_days_since_the_module_began_due_date <- OULADDataCleaner$returnReplacementColumn()
# --
# -- Data checking
# Check that at least one of student_id, assessment_id, presentation_id, and module_id in the same row is unique
# For testing purposes, I added a row that shares 4 IDs to see if my code would detect the duplicate row
# mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable <- rbind(mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable, list("AAA", "2013J", 704156, 1752, 18, "No", 67, "TMA", 20, 11, -18, "In/Completed course", "M", "Ireland", "HE Qualification", "90-100%", ">55",0, 120, "N", "Fail", 168))
# Return a list of rows that share 4 IDs
output <-
group_by(
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable,
student_id,
assessment_id,
presentation_id,
module_id
) %>% filter(n() > 1)
numberOfRowsThatShare4IDS <- nrow(output)
# --
# -- Work out whether the original weighted value even adds up to 100
OULADDatasetQuerier$setQuery("SELECT
module_id,
presentation_id,
student_id,
SUM(assessment_weight) AS 'sum_assessment_weight',
CASE
WHEN SUM(assessment_weight) != 0 THEN (100 / SUM(assessment_weight))
END 'non_zero_weighting_sum_scale_assessment_weightings_by_this_value',
CASE
WHEN SUM(assessment_weight) == 0 THEN COUNT(assessment_weight)
END 'zero_weighting_sum_number_of_assessments_hundred_divide_by_this_value_for_each_assessment'
FROM
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable
WHERE
assessment_type NOT LIKE '%Exam%'
GROUP BY
module_id,
presentation_id,
student_id")
checkingAssessmentWeights <- OULADDatasetQuerier$returnQueryResultKeepColNames()
view(checkingAssessmentWeights)
# -- Putting this alongside the original table
mergingAndFixing <-
merge(
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable,
checkingAssessmentWeights,
by = c("module_id", "presentation_id", "student_id"),
all = T
)
# view(mergingAndFixing)
OULADDatasetQuerier$setQuery("SELECT
module_id,
presentation_id,
student_id,
assessment_id,
student_score,
assessment_type,
assessment_weight,
sum_assessment_weight,
non_zero_weighting_sum_scale_assessment_weightings_by_this_value,
zero_weighting_sum_number_of_assessments_hundred_divide_by_this_value_for_each_assessment
FROM
mergingAndFixing")
checkingThisOut <- OULADDatasetQuerier$returnQueryResultKeepColNames()
# view(checkingThisOut)
# --
# -- Creation of a new column that determines the weighted score
hopingThisWorks <-
checkingThisOut %>%
mutate(
new_assessment_weight = (
sum_assessment_weight = case_when(
assessment_type != "Exam" &
sum_assessment_weight == 0 ~ 100 / zero_weighting_sum_number_of_assessments_hundred_divide_by_this_value_for_each_assessment,
assessment_type != "Exam" &
sum_assessment_weight != 0 ~ assessment_weight * non_zero_weighting_sum_scale_assessment_weightings_by_this_value,
assessment_type == "Exam" ~ assessment_weight
)
),
.after = assessment_weight
)
# --
hopingThisWorks <- arrange(hopingThisWorks, student_id)
# view(hopingThisWorks)
# -- Removing junk columns
OULADDataCleaner$setDataset(hopingThisWorks)
OULADDataCleaner$removeJunkColumns(c(5, 6, 7, 9, 10, 11))
hopingThisWorks <- OULADDataCleaner$returnDataset()
# view(hopingThisWorks)
# -- Merging, it's right now
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable <-
merge(
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable,
hopingThisWorks,
by = c("module_id", "presentation_id", "student_id", "assessment_id"),
all = T
)
# view(mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable)
# -- Creation of a new column that determines the weighted score
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable <-
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable %>%
mutate(weighted_score = ((student_score * new_assessment_weight) / 100),
.after = new_assessment_weight)
view(
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable
)
# --
# -- Creation of a new column that contains the difference between the due date and when the student handed in the assignment
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable <-
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable %>%
mutate(
difference_between_due_date_and_hand_in_date = (
assessment_days_since_the_module_began_due_date - student_days_it_took_to_submit_assessment
),
.after = assessment_days_since_the_module_began_due_date
)
# --
# -- Set how much the exam and other assessment items weigh so they add up to 100%
# For the case where the student does an exam as well as other assessments in a module
# This will make working out the cumulative GPA possible
newExamWeightValue = 0.4 # Exam weighed at 40% for example
newWeightingOfAllOtherAssessmentsValue = 1 - newExamWeightValue # Other assessments weighed at 60% for example
# -- Creation of a new column for the new weight of every assessment type
# For the case where the student does an exam as well as other assessments in a module
addColumnForNewWeightingOfAssessments <-
mutate(
mergedAssessmentTableAndStudentAssessmentTableAndStudentRegistrationTableAndStudentInfoAndCoursesTable,
assessment_weight_exam_and_other_assessments_done = ifelse(
assessment_type == "Exam",
newExamWeightValue * new_assessment_weight,
newWeightingOfAllOtherAssessmentsValue * new_assessment_weight
),
.after = weighted_score
)
# view(addColumnForNewWeightingOfAssessments)
# --
# -- Creation of a new column for the new weighted score based on the new weight for every assessment type
# For the case where the student does an exam as well as other assessments in a module
addColumnForNewWeightedScoresOfAssessments <-
addColumnForNewWeightingOfAssessments %>%
mutate(
weighted_score_exam_and_other_assessments_done = ((
student_score * assessment_weight_exam_and_other_assessments_done
) / 100
),
.after = assessment_weight_exam_and_other_assessments_done
)
# view(addColumnForNewWeightedScoresOfAssessments)
# --
# -- Calculation and creation of a new column for
# - The sum of the weighted scores for each module
# - If student has finished the course
# - If student has taken an exam
OULADDatasetQuerier$setQuery('SELECT
student_id,
module_id,
presentation_id,
number_of_credits_the_module_is_worth,
SUM(weighted_score)
AS sum_weighted_score,
SUM(weighted_score_exam_and_other_assessments_done)
AS sum_weighted_score_exam_and_other_assessments_done,
SUM(CASE WHEN assessment_type LIKE \'%Exam%\' THEN 1 ELSE 0 END)
AS has_student_taken_an_exam,
case when student_final_result_for_the_module LIKE \'%Withdrawn%\' then \'No\'
else \'Yes\' end did_student_finish_the_course
FROM
addColumnForNewWeightedScoresOfAssessments
GROUP BY student_id, module_id, presentation_id')
workOutTheSumOfTheWeightedScoresAndIfStudentHasTakenAnExamAndIfStudentHasFinishedTheCourse <-
OULADDatasetQuerier$returnQueryResultKeepColNames()
view(
workOutTheSumOfTheWeightedScoresAndIfStudentHasTakenAnExamAndIfStudentHasFinishedTheCourse
)
# -- Creation of a new column for the grade a student gets
# - Considering if they withdrew from the course or not
# - Considering if they took an exam or not
addAGradeColumnBasedOnTheNewAssessmentWeighting <-
workOutTheSumOfTheWeightedScoresAndIfStudentHasTakenAnExamAndIfStudentHasFinishedTheCourse %>%
mutate(grade = (
score = case_when(
did_student_finish_the_course == "No" ~ "WNF",
did_student_finish_the_course == "Yes" &
has_student_taken_an_exam > 0 ~ case_when(
sum_weighted_score_exam_and_other_assessments_done >= 85 ~ "HD",
sum_weighted_score_exam_and_other_assessments_done < 85 &
sum_weighted_score_exam_and_other_assessments_done > 74 ~ "D",
sum_weighted_score_exam_and_other_assessments_done < 75 &
sum_weighted_score_exam_and_other_assessments_done > 64 ~ "Cr",
sum_weighted_score_exam_and_other_assessments_done < 65 &
sum_weighted_score_exam_and_other_assessments_done > 49 ~ "P",
sum_weighted_score_exam_and_other_assessments_done <= 49 ~ "F"
),
did_student_finish_the_course == "Yes" &
has_student_taken_an_exam <= 0 ~ case_when(
sum_weighted_score >= 85 ~ "HD",
sum_weighted_score < 85 & sum_weighted_score > 74 ~ "D",
sum_weighted_score < 75 & sum_weighted_score > 64 ~ "Cr",
sum_weighted_score < 65 & sum_weighted_score > 49 ~ "P",
sum_weighted_score <= 49 ~ "F"
)
)
),
.after = did_student_finish_the_course)
# --
view(addAGradeColumnBasedOnTheNewAssessmentWeighting)
# -- Creation of a new column that groups the module ID with the presentation ID
addAGradeColumnBasedOnTheNewAssessmentWeighting <-
addAGradeColumnBasedOnTheNewAssessmentWeighting %>%
mutate(
group_ids_together = paste(module_id, presentation_id, sep = ", "),
.after = presentation_id
)
# --
# -- Creation of a new column that converts the grade to it's numerical equivalent
addNumericalEquivalentToGradeColumn <-
addAGradeColumnBasedOnTheNewAssessmentWeighting %>%
mutate(numerical_grade_equivalent = (
grade = case_when(
grade == "HD" ~ 7,
grade == "D" ~ 6,
grade == "Cr" ~ 5,
grade == "P" ~ 4,
grade == "F" ~ 1.5,
grade == "WF" ~ NA
)
),
.after = grade)
# --
# -- Creation of a new column that works out the grade points
OULADDatasetQuerier$setQuery(
'SELECT
student_id,
group_ids_together,
(numerical_grade_equivalent * number_of_credits_the_module_is_worth)
AS grade_points,
SUM(number_of_credits_the_module_is_worth)
AS course_credits
FROM
addNumericalEquivalentToGradeColumn
GROUP BY student_id, group_ids_together')
workOutTheGP <- OULADDatasetQuerier$returnQueryResultKeepColNames()
# --
# -- Creation of the new column that works out the cumulative GPA
OULADDatasetQuerier$setQuery(
'SELECT
student_id,
ROUND(SUM(grade_points) / SUM(course_credits), 2)
AS cumulative_gpa
FROM
workOutTheGP
GROUP BY student_id')
workOutTheCGPA <- OULADDatasetQuerier$returnQueryResultKeepColNames()
view(workOutTheCGPA)
view(workOutTheGP)
